name: Conventional Commits

on:
  pull_request:
    branches: [ main, develop ]
    types: [opened, edited, synchronize, reopened]

jobs:
  conventional-commits:
    name: Validate Conventional Commits
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Validate PR Title
      uses: amannn/action-semantic-pull-request@v5
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        types: |
          feat
          fix
          docs
          style
          refactor
          perf
          test
          build
          ci
          chore
          revert
        requireScope: false
        disallowScopes: |
          release
        subjectPattern: ^(?![A-Z]).+$
        subjectPatternError: |
          The subject "{subject}" found in the pull request title "{title}"
          didn't match the configured pattern. Please ensure that the subject
          doesn't start with an uppercase character.

    - name: Validate Commit Messages
      run: |
        echo "ðŸ” Validating commit messages..."

        # Get all commits in this PR
        git fetch origin main
        COMMITS=$(git rev-list --reverse origin/main..HEAD)

        # Conventional commit pattern
        PATTERN="^(feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert)(\(.+\))?: .{1,50}"

        INVALID_COMMITS=()

        while IFS= read -r commit; do
          # Properly quote commit variable and limit message length
          MESSAGE=$(git log --format=%s -n 1 "$commit" | head -c 200)

          # Use printf instead of echo to avoid escape sequence interpretation
          printf "Checking commit: %s\n" "$commit"
          printf "Message: %s\n" "$MESSAGE"

          # Skip merge commits (they don't need to follow conventional commits)
          if printf "%s" "$MESSAGE" | grep -qE "^Merge "; then
            printf "  -> Skipping merge commit\n"
            continue
          fi

          if ! printf "%s" "$MESSAGE" | grep -qE "$PATTERN"; then
            # Store safely with proper quoting
            INVALID_COMMITS+=("$(printf "%s: %s" "$commit" "$MESSAGE")")
          fi
        done < <(echo "$COMMITS")

        if [ ${#INVALID_COMMITS[@]} -gt 0 ]; then
          echo "âŒ Found invalid commit messages:"
          printf '%s\n' "${INVALID_COMMITS[@]}"
          echo ""
          echo "â„¹ï¸  Commit messages should follow the Conventional Commits specification:"
          echo "   <type>[optional scope]: <description>"
          echo ""
          echo "   Types: feat, fix, docs, style, refactor, perf, test, build, ci, chore, revert"
          echo "   Examples:"
          echo "   - feat: add user authentication"
          echo "   - fix: resolve memory leak in data processing"
          echo "   - docs: update API documentation"
          echo "   - refactor: simplify certificate validation logic"
          exit 1
        else
          echo "âœ… All commit messages follow conventional commits format"
        fi

    - name: Preview Next Version
      id: preview
      run: |
        echo "ðŸ”® Previewing next version based on commits..."

        CURRENT_VERSION=$(cat VERSION)
        echo "Current version: $CURRENT_VERSION"

        # Get all commits in this PR
        git fetch origin main
        COMMITS=$(git rev-list --reverse origin/main..HEAD)

        # Analyze commit types
        HAS_BREAKING=false
        HAS_FEAT=false
        HAS_FIX=false

        while IFS= read -r commit; do
          # Properly quote commit variable and limit message/body length
          MESSAGE=$(git log --format=%s -n 1 "$commit" | head -c 200)
          BODY=$(git log --format=%b -n 1 "$commit" | head -c 1000)

          # Check for breaking changes using printf for safety
          if printf "%s" "$MESSAGE" | grep -q "!:" || printf "%s" "$BODY" | grep -q "BREAKING CHANGE"; then
            HAS_BREAKING=true
          elif printf "%s" "$MESSAGE" | grep -q "^feat"; then
            HAS_FEAT=true
          elif printf "%s" "$MESSAGE" | grep -q "^fix"; then
            HAS_FIX=true
          fi
        done < <(echo "$COMMITS")

        # Calculate next version
        IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"

        if [ "$HAS_BREAKING" = true ]; then
          NEXT_VERSION="$((MAJOR + 1)).0.0"
          BUMP_TYPE="major"
        elif [ "$HAS_FEAT" = true ]; then
          NEXT_VERSION="$MAJOR.$((MINOR + 1)).0"
          BUMP_TYPE="minor"
        elif [ "$HAS_FIX" = true ]; then
          NEXT_VERSION="$MAJOR.$MINOR.$((PATCH + 1))"
          BUMP_TYPE="patch"
        else
          NEXT_VERSION="$CURRENT_VERSION"
          BUMP_TYPE="none"
        fi

        echo "next_version=$NEXT_VERSION" >> $GITHUB_OUTPUT
        echo "bump_type=$BUMP_TYPE" >> $GITHUB_OUTPUT
        echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT

        echo "Next version would be: $NEXT_VERSION (${BUMP_TYPE} bump)"

    - name: Comment PR with Version Preview
      uses: actions/github-script@v7
      env:
        NEXT_VERSION: ${{ steps.preview.outputs.next_version }}
        BUMP_TYPE: ${{ steps.preview.outputs.bump_type }}
        CURRENT_VERSION: ${{ steps.preview.outputs.current_version }}
      with:
        script: |
          // Use environment variables to avoid injection
          const nextVersion = process.env.NEXT_VERSION;
          const bumpType = process.env.BUMP_TYPE;
          const currentVersion = process.env.CURRENT_VERSION;

          // Validate inputs (defense in depth)
          if (!/^\d+\.\d+\.\d+$/.test(nextVersion) || !/^\d+\.\d+\.\d+$/.test(currentVersion)) {
            throw new Error('Invalid version format');
          }
          if (!['major', 'minor', 'patch', 'none'].includes(bumpType)) {
            throw new Error('Invalid bump type');
          }

          let emoji = 'ðŸ“¦';
          if (bumpType === 'major') emoji = 'ðŸ’¥';
          else if (bumpType === 'minor') emoji = 'âœ¨';
          else if (bumpType === 'patch') emoji = 'ðŸ›';
          else if (bumpType === 'none') emoji = 'ðŸ“';

          const body = `## ${emoji} Version Preview

          **Current Version:** \`${currentVersion}\`
          **Next Version:** \`${nextVersion}\` (\`${bumpType}\` bump)

          ${bumpType === 'major' ? 'âš ï¸ **Breaking Change Detected** - This will trigger a major version bump!' : ''}
          ${bumpType === 'minor' ? 'ðŸŽ‰ **New Feature** - This will trigger a minor version bump!' : ''}
          ${bumpType === 'patch' ? 'ðŸ”§ **Bug Fix** - This will trigger a patch version bump!' : ''}
          ${bumpType === 'none' ? 'ðŸ“š **Documentation/Chores** - No version bump needed!' : ''}

          ---
          *This preview is based on conventional commit analysis. The actual version will be determined when the release is created.*`;

          // Find existing comment
          const comments = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
          });

          const existingComment = comments.data.find(comment =>
            comment.user.login === 'github-actions[bot]' &&
            comment.body.includes('Version Preview')
          );

          if (existingComment) {
            // Update existing comment
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: existingComment.id,
              body: body
            });
          } else {
            // Create new comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: body
            });
          }
